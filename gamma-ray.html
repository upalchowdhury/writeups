<!DOCTYPE html>
<html>

<head>
    <title>ZK-Hack gamma-ray</title>
    <!-- MathJax for LaTeX -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Highlight.js for Rust Code -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<style>
    body {
        font-family: Arial, sans-serif;
        /* Use a modern font */
    }

    .highlighted-text {
        background-color: rgba(255, 255, 255, 0.9);
        /* Very light background, almost white */
        color: #333;
        /* Dark grey text for contrast */
        padding: 10px;
        /* Padding inside the highlight box */
        margin: 20px 0;
        /* Margin outside the highlight box */
        border: 1px solid #aaa;
        /* Light grey border for subtle contrast */
        font-style: italic;
    }

    .flex-container {
        display: flex;
        justify-content: center;
        /* Center horizontally */
        align-items: center;
        /* Center vertically */
        height: 60vh;
        /* Adjust the height as needed */
    }

    .text-container {
        display: flex;
        justify-content: left;
        /* Center horizontally */
        align-items: left;
        /* Center vertically */
        height: 30vh;
        /* Adjust the height as needed */
    }
</style>


<body>
    <h2>Problem</h2>
    <div class="highlighted-text">
        <p>Bob was deeply inspired by the Zcash design [1] for private transactions and had some pretty cool ideas on
            how to adapt
            it for his requirements. He was also inspired by the Mina design for the lightest blockchain and wanted to
            combine the
            two. In order to achieve that, Bob used the MNT6753 cycle of curves to enable efficient infinite recursion,
            and used
            elliptic curve public keys to authorize spends. He released a first version of the system to the world and
            Alice soon
            announced she was able to double spend by creating two different nullifiers for the same key...</p>
    </div>

    <h2>Hints</h2>
    <p>
    <ul>
        <li>Lemma 5.4.7 in the <a href="https://zips.z.cash/protocol/protocol.pdf">Zcash specs</a>

            mentions Bob's reasoning on why to only use the x coordinate when storing the public keys -- "" </li>

        <li>Note that the MNT curves are represented in Weierstrass from in the circuit, and use the fact that both
            (x,y) and
            (x,-y) are valid points for spending</li>


        <li>Make sure you negate the y coordinate in the right scalar field, being the base field of MNT4</li>
    </ul>

    </p>
    <h2>Elliptic Curve properties</h2>

    <p>
        Elliptic curves have the following formula,
        \begin{equation}
        y^2 \equiv x^3 + ax + b \pmod{p}
        \end{equation}

        where \(x\) and \(y\) to be elements of a finite field also known as the base field and \(p\) is a large prime
        number. This is an elliptic curve
        over finite field using \(mod\) \(p\) rather than a smooth elliptic curve.
    <h4>Relevant elliptic curve (over finite field) properties :</h4>
    <ul>
        <li>Elliptic Curve forms an <a href="https://en.wikipedia.org/wiki/Abelian_group">abelian group</a> under
            addition. Points in the curve are part of a group such that if we take two points, we can produce a third
            point on the curve
            according to the rules of group theory.</li>

        <li>Elliptic curve points with connecting which is adding two points and flipping which is reflecting point
            across \(x\) axis to get the result of the point addition forms a cyclic group (given finite field is used).
            And a cyclic group \(G\) has an element \(g\) such that every point in the group can be generated by
            repeatedly adding
            generator point to itself.
        </li>

        <li>The curve includes a special point at infinity \(O\) which acts as the identity element for point addition.
            For any point

            \(P\), there is an inverse point \(−P\) such that \(P+(−P)=O\). The inverse of a point \(P(x,y)\) is the
            point \((x,−y)\), reflecting \(P\) over the x-axis.</li>

    </ul>

    <div class="flex-container">
        <img src="ec.png" alt="Elliptic Curve with mod 23">
    </div>
    <div class="text-container">
        <span class="latex">This curve is generated based on \(y^2 \equiv x^3 + 3 \pmod{23}\).
            Its easily visible the symmetric nature of the elliptic curve points.</span>
    </div>

    A good place to review many zk-related concepts: <a
        href="https://nmohnblatt.github.io/zk-jargon-decoder/foreword.html">zkJargon</a>
    </p>


    <p>
        MNT cycle of curves consists of two pairing-friendly curves with a property such that the first curve's base and
        scalar
        fields are the other curve's scalar and base fields, respectively. More on this <a
            href="https://arxiv.org/pdf/1803.02067.pdf">MNT Cycle of Curves</a>
    </p>


    <h2>Arkworks primer</h2>
    <p>
        <a href="https://www.youtube.com/watch?v=Bz2KN_h3VKM&t=90s">Arkworks</a> is one of the popular ecosystem of
        libraries based in rust for developing zkSNARKs. It has common set of traits and <a
            href="https://github.com/arkworks-rs/algebra/blob/master/ec/README.md"> apis</a> to work with different
        crypto primitivs (ecs,ffs,hash) without the need to write them from scratch.
        Since its written in rust, its important to understand how rust works in terms of designing libraries.
    </p>



    <h2>Solution</h2>
    <p> The lemma 5.4.7 of zcash paper proofs the properties of points on an elliptic curve, specifically within the
        context of a subgroup \(J(r)\) of prime order such
        that for a given point \(P=(u,v)\) in the subgroup \(J(r)\), the point with coordinates \((u,−v)\) does not
        belong to \(J(r)\).
        The proof leverages the properties of elliptic curves and the behavior of points under the "doubling" operation.
        While in MNT curve it uses <code>Weierstrass</code> form meaning both \((x,y)\) and \((x,-y)\) are valid points
        in the curve group.
        Since Bob uses <code>MNT6753</code> cycle of curves for key generation, both both \((x,y)\) and \((x,-y)\) are
        valid points in the group. Additonally MNT6753 are cycle of curves which have the property of base field of one
        curve being the
        scalar field of the next. So we used base field of MNT6 curve which is the scalar field of MNT4 curve.
    </p>
    <p> Public key generation process using elliptic curve is as follows,

        \(pubk = kG\) where \(k\) is a scalar in the scalar field and \(G\) is the generator point of the particular
        elliptic curve group.</p>

    <p>
        By subtracting the original scalar (secret key) from the curve order often works to find another scalar that,
        when multiplied
        with the
        generator of an elliptic curve, produces a point with the same x-coordinate as the original scalar does. This is
        due to
        the properties of elliptic curves over finite fields, particularly the symmetry about the x-axis</p>


    <p> For a given elliptic curve, let's denote
    <ul>
        <li>The curve order as \(n\)</li>
        <li>The original scalar as \(k\)</li>
        <li>The generator point of the curve as \(G\)</li>
    </ul>

    The point obtained by multiplying the generator
    \(G\) by the scalar

    \(k\) is denoted as \(kG=(x,y)\). Due to the symmetric nature of elliptic curves, the point

    \((x,−y)\) is also on the curve. This point can be denoted as \((nG−kG)\) because:
    </p>



    <p>
    <ol>
        <li>The order of the curve \(n\) is the total number of points on the curve.</li>
        <li>Multiplying the generator point \(G\) by the curve order n yields the identity element (point at infinity),
            so

            \(nG\) is effectively the same as the identity element.</li>

        <li>Subtracting \(kG\) from the identity element is equivalent to adding the inverse of

            \(kG\), which is \((x,−y)\).</li>


        Therefore, the scalar \(n−k\) will yield the point \((x,−y)\) when multiplied by \(G\), having the same
        x-coordinate but the negated y-coordinate.

    </ol>

    </p>

    <p>Following is solution code that passed the test.</p>

    <pre><code class="rust">

    // Reading data secret into bigint as by default rust supports upto 128 bits. 
    let leaked_secret_bigint = leaked_secret.into_bigint();
    // Getting the curve order
    let mut secret_hack_bigint = MNT6BigFr::MODULUS.clone();
    // Subtracting the secret from curve order
    secret_hack_bigint.sub_with_borrow(&leaked_secret_bigint);
    let secret_hack = MNT4BigFr::from(secret_hack_bigint);
    let nullifier_hack = <LeafH as CRHScheme>::evaluate(&leaf_crh_params, vec![secret_hack]).unwrap();
    // This tests to see if they generate different nullifiers
    assert_ne!(nullifier, nullifier_hack);
    
    </code></pre>

    <p>From the above code we can verify that both \(y\) and \(- y\) resulting in same \(x\) but this will generate
        different nullifier since the \(-y\) value is different.</p>

    <h2>Mitigation</h2>
    <p>
    <ul>
        <li>
            Include both \(x\) and \(y\) coordinates of the pubic key in the leaf that is committed to the Merkle tree.
        </li>
        <li>
            Use <code>RedJubjub curve</code> with required cryptographic scheme instead of <code>MNT</code> cycle of
            curves cryptographic scheme mentioned in <a href="https://zips.z.cash/protocol/protocol.pdf">zcash</a>.
            Note that this solution is not tested yet.
        </li>
    </ul>
    </p>
</body>

</html>